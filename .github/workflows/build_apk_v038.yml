name: Build Android APK v0.3.8 - AOD service + Nightly Planner (arm64)

on:
  workflow_dispatch: {}

defaults:
  run:
    shell: bash

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Flutter (stable)
        uses: subosito/flutter-action@v2
        with:
          channel: stable

      - name: Create Flutter project if missing (no overwrite)
        run: |
          set -euo pipefail
          if [ ! -f pubspec.yaml ]; then
            flutter create . --platforms=android --project-name anti_procrastination --org com.example.antipro
          fi

      - name: Detect legacy Android v1 embedding
        id: detect_v1
        run: |
          set -euo pipefail
          hits="$(grep -R -nE 'io\.flutter\.app\.Flutter(Application|Activity)|registerWith\(' android || true)"
          if [ -n "$hits" ]; then
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "$hits"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Regenerate android/ with embedding v2 (if needed)
        if: ${{ steps.detect_v1.outputs.found == 'true' }}
        run: |
          set -euo pipefail
          rm -rf android
          flutter create . --platforms=android --project-name anti_procrastination --org com.example.antipro --overwrite

      - name: Generate temp keystore & key.properties (sign release)
        run: |
          set -euo pipefail
          mkdir -p android/app
          keytool -genkey -noprompt \
            -keystore android/app/upload-keystore.jks \
            -alias upload \
            -storepass android -keypass android \
            -keyalg RSA -keysize 2048 -validity 10000 \
            -dname "CN=Temp, OU=CI, O=CI, L=, S=, C=US"
          cat > android/key.properties <<'PROPS'
          storePassword=android
          keyPassword=android
          keyAlias=upload
          storeFile=upload-keystore.jks
          PROPS

      - name: "Inject native (Kotlin: Service/Lock/AOD + Nightly Planner + Manifest)"
        run: |
          set -euo pipefail
          ORG_PATH="com/example/antipro"
          mkdir -p android/app/src/main/kotlin/$ORG_PATH
          mkdir -p android/app/src/main/res/layout

          # ---------- MainActivity.kt (adds plannerEnable/plannerDisable) ----------
          cat > android/app/src/main/kotlin/$ORG_PATH/MainActivity.kt <<'KOT'
          package com.example.antipro

          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.content.IntentFilter
          import android.os.Build
          import android.os.Handler
          import android.os.Looper
          import io.flutter.embedding.android.FlutterActivity
          import io.flutter.embedding.engine.FlutterEngine
          import io.flutter.plugin.common.MethodChannel

          class MainActivity : FlutterActivity() {
              private val CHANNEL = "focus_service"
              private var eventsReceiver: BroadcastReceiver? = null

              companion object {
                  var channel: MethodChannel? = null
                  fun emit(method: String, args: Map<String, Any?>? = null) {
                      val ch = channel ?: return
                      Handler(Looper.getMainLooper()).post { ch.invokeMethod(method, args) }
                  }
              }

              override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
                  super.configureFlutterEngine(flutterEngine)
                  val ch = MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL)
                  channel = ch
                  ch.setMethodCallHandler { call, result ->
                      when (call.method) {
                          "start" -> {
                              val minutes = (call.argument<Int>("minutes") ?: 25)
                              val dim = (call.argument<Double>("dim") ?: 0.05).toFloat()
                              val lock = (call.argument<Boolean>("lock") ?: false)

                              val svc = Intent(this, FocusForegroundService::class.java)
                              svc.putExtra("minutes", minutes)
                              startForegroundServiceCompat(svc)

                              if (lock) {
                                  val intent = Intent(this, FocusLockActivity::class.java)
                                  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
                                  intent.putExtra("dim", dim)
                                  startActivity(intent)
                              }
                              result.success(true)
                          }
                          "stop" -> {
                              stopService(Intent(this, FocusForegroundService::class.java))
                              result.success(true)
                          }
                          // Nightly planner APIs
                          "plannerEnable" -> {
                              val hour = call.argument<Int>("hour") ?: 21
                              val minute = call.argument<Int>("minute") ?: 30
                              NightlyPlanner.enable(this, hour, minute)
                              result.success(true)
                          }
                          "plannerDisable" -> {
                              NightlyPlanner.disable(this)
                              result.success(true)
                          }
                          else -> result.notImplemented()
                      }
                  }
              }

              override fun onStart() {
                  super.onStart()
                  val filter = IntentFilter().apply {
                      addAction("FOCUS_TICK"); addAction("FOCUS_FINISH"); addAction("FOCUS_STOP"); addAction("FOCUS_INTERRUPTION")
                  }
                  eventsReceiver = object : BroadcastReceiver() {
                      override fun onReceive(context: Context?, intent: Intent?) {
                          when (intent?.action) {
                              "FOCUS_TICK" -> emit("onTick", mapOf("remaining" to intent.getIntExtra("remaining", 0)))
                              "FOCUS_FINISH" -> emit("onFinish")
                              "FOCUS_STOP" -> emit("onStop")
                              "FOCUS_INTERRUPTION" -> emit("onInterruption")
                          }
                      }
                  }
                  registerReceiver(eventsReceiver, filter)
              }

              override fun onStop() {
                  try { unregisterReceiver(eventsReceiver) } catch (_: Exception) {}
                  eventsReceiver = null
                  super.onStop()
              }

              private fun startForegroundServiceCompat(intent: Intent) {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) startForegroundService(intent) else startService(intent)
              }
          }
          KOT

          # ---------- FocusForegroundService.kt ----------
          cat > android/app/src/main/kotlin/$ORG_PATH/FocusForegroundService.kt <<'KOT'
          package com.example.antipro

          import android.app.Notification
          import android.app.NotificationChannel
          import android.app.NotificationManager
          import android.app.PendingIntent
          import android.app.Service
          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.content.IntentFilter
          import android.os.Build
          import android.os.CountDownTimer
          import android.os.IBinder
          import androidx.core.app.NotificationCompat

          class FocusForegroundService : Service() {
              private var timer: CountDownTimer? = null
              private var remainingMs: Long = 0L
              private var screenRx: BroadcastReceiver? = null

              override fun onCreate() {
                  super.onCreate()
                  createChannel()
                  val f = IntentFilter().apply { addAction(Intent.ACTION_USER_PRESENT) }
                  screenRx = object : BroadcastReceiver() {
                      override fun onReceive(context: Context?, intent: Intent?) {
                          if (intent?.action == Intent.ACTION_USER_PRESENT && remainingMs > 0L) {
                              sendBroadcast(Intent("FOCUS_INTERRUPTION"))
                          }
                      }
                  }
                  registerReceiver(screenRx, f)
              }

              override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
                  if (intent?.action == "STOP") {
                      sendBroadcast(Intent("FOCUS_STOP"))
                      stopForeground(STOP_FOREGROUND_REMOVE)
                      stopSelf()
                      try {
                          val launcher = packageManager.getLaunchIntentForPackage(packageName)
                          launcher?.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
                          if (launcher != null) startActivity(launcher)
                      } catch (_: Exception) {}
                      return START_NOT_STICKY
                  }
                  val minutes = intent?.getIntExtra("minutes", 25) ?: 25
                  remainingMs = (minutes * 60 * 1000L)
                  startForeground(NOTI_ID, buildNotification(formatRemaining()))
                  timer?.cancel()
                  timer = object : CountDownTimer(remainingMs, 1000) {
                      override fun onTick(ms: Long) {
                          remainingMs = ms
                          notifyUpdate()
                          val i = Intent("FOCUS_TICK"); i.putExtra("remaining", (remainingMs / 1000).toInt()); sendBroadcast(i)
                      }
                      override fun onFinish() {
                          sendBroadcast(Intent("FOCUS_FINISH"))
                          stopForeground(STOP_FOREGROUND_DETACH)
                          stopSelf()
                      }
                  }.start()
                  return START_STICKY
              }

              override fun onDestroy() {
                  timer?.cancel()
                  try { unregisterReceiver(screenRx) } catch (_: Exception) {}
                  super.onDestroy()
              }

              override fun onBind(intent: Intent?): IBinder? = null

              private fun notifyUpdate() {
                  val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                  nm.notify(NOTI_ID, buildNotification(formatRemaining()))
              }

              private fun formatRemaining(): String {
                  val totalSec = (remainingMs / 1000).toInt()
                  val m = totalSec / 60
                  val s = totalSec % 60
                  return String.format("%02d:%02d", m, s)
              }

              private fun createChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                      val ch = NotificationChannel(CHANNEL_ID, "Focus", NotificationManager.IMPORTANCE_DEFAULT)
                      ch.setShowBadge(false)
                      nm.createNotificationChannel(ch)
                  }
              }

              private fun buildNotification(text: String): Notification {
                  val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
                      PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE else PendingIntent.FLAG_UPDATE_CURRENT
                  val pi = PendingIntent.getActivity(
                      this, 0,
                      Intent(this, FocusLockActivity::class.java).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP),
                      flags
                  )
                  val stopPi = PendingIntent.getService(this, 1, Intent(this, FocusForegroundService::class.java).setAction("STOP"), flags)
                  return NotificationCompat.Builder(this, CHANNEL_ID)
                      .setSmallIcon(android.R.drawable.ic_lock_idle_alarm)
                      .setContentTitle("专注进行中")
                      .setContentText("剩余: $text")
                      .setOngoing(true)
                      .setOnlyAlertOnce(true)
                      .setContentIntent(pi)
                      .addAction(0, "停止", stopPi)
                      .setCategory(NotificationCompat.CATEGORY_SERVICE)
                      .build()
              }

              companion object {
                  private const val CHANNEL_ID = "focus_channel"
                  private const val NOTI_ID = 2001
              }
          }
          KOT

          # ---------- FocusLockActivity.kt (extends Activity) ----------
          cat > android/app/src/main/kotlin/$ORG_PATH/FocusLockActivity.kt <<'KOT'
          package com.example.antipro

          import android.app.Activity
          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.content.IntentFilter
          import android.os.Bundle
          import android.view.View
          import android.view.WindowManager
          import android.widget.TextView

          class FocusLockActivity : Activity() {
              private var tv: TextView? = null
              private val rx = object : BroadcastReceiver() {
                  override fun onReceive(context: Context?, intent: Intent?) {
                      when (intent?.action) {
                          "FOCUS_TICK" -> {
                              val sec = intent.getIntExtra("remaining", 0)
                              val m = sec / 60; val s = sec % 60
                              tv?.text = String.format("%02d:%02d", m, s)
                          }
                          "FOCUS_FINISH", "FOCUS_STOP" -> finish()
                      }
                  }
              }

              override fun onCreate(savedInstanceState: Bundle?) {
                  super.onCreate(savedInstanceState)
                  setContentView(R.layout.activity_focus_lock)
                  tv = findViewById(R.id.countdownText)

                  window.addFlags(
                      WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED or
                      WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON or
                      WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
                  )
                  val dim = intent.getFloatExtra("dim", 0.05f).coerceIn(0.01f, 0.2f)
                  window.attributes = window.attributes.apply { screenBrightness = dim }

                  window.decorView.systemUiVisibility = (
                      View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or
                      View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or
                      View.SYSTEM_UI_FLAG_FULLSCREEN)
              }

              override fun onResume() {
                  super.onResume()
                  registerReceiver(rx, IntentFilter().apply {
                      addAction("FOCUS_TICK"); addAction("FOCUS_FINISH"); addAction("FOCUS_STOP")
                  })
              }

              override fun onPause() {
                  try { unregisterReceiver(rx) } catch (_: Exception) {}
                  super.onPause()
              }
          }
          KOT

          # ---------- NightlyPlanner.kt (AlarmManager + Notification) ----------
          cat > android/app/src/main/kotlin/$ORG_PATH/NightlyPlanner.kt <<'KOT'
          package com.example.antipro

          import android.app.AlarmManager
          import android.app.NotificationChannel
          import android.app.NotificationManager
          import android.app.PendingIntent
          import android.content.Context
          import android.content.Intent
          import android.os.Build
          import androidx.core.app.NotificationCompat
          import java.util.Calendar

          object NightlyPlanner {
              private const val PREFS = "antipro"
              private const val KEY_ENABLED = "planner_enabled"
              private const val KEY_HOUR = "planner_hour"
              private const val KEY_MINUTE = "planner_minute"
              private const val NOTI_ID = 3001
              const val CHANNEL_ID = "planner_channel"

              fun enable(context: Context, hour: Int, minute: Int) {
                  val prefs = context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
                  prefs.edit().putBoolean(KEY_ENABLED, true).putInt(KEY_HOUR, hour).putInt(KEY_MINUTE, minute).apply()
                  ensureChannel(context)
                  schedule(context, hour, minute)
              }

              fun disable(context: Context) {
                  val prefs = context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
                  prefs.edit().putBoolean(KEY_ENABLED, false).apply()
                  cancel(context)
              }

              fun rescheduleFromPrefs(context: Context) {
                  val prefs = context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
                  if (prefs.getBoolean(KEY_ENABLED, false)) {
                      val h = prefs.getInt(KEY_HOUR, 21)
                      val m = prefs.getInt(KEY_MINUTE, 30)
                      schedule(context, h, m)
                  }
              }

              private fun schedule(context: Context, hour: Int, minute: Int) {
                  val am = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
                  val pi = pending(context)
                  val cal = Calendar.getInstance().apply {
                      timeInMillis = System.currentTimeMillis()
                      set(Calendar.HOUR_OF_DAY, hour)
                      set(Calendar.MINUTE, minute)
                      set(Calendar.SECOND, 0)
                      set(Calendar.MILLISECOND, 0)
                  }
                  var trigger = cal.timeInMillis
                  if (trigger <= System.currentTimeMillis()) trigger += 24 * 60 * 60 * 1000L
                  am.setInexactRepeating(AlarmManager.RTC_WAKEUP, trigger, AlarmManager.INTERVAL_DAY, pi)
              }

              private fun cancel(context: Context) {
                  val am = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
                  am.cancel(pending(context))
              }

              fun showReminder(context: Context) {
                  ensureChannel(context)
                  val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                  val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
                      PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE else PendingIntent.FLAG_UPDATE_CURRENT
                  val openApp = PendingIntent.getActivity(
                      context, 0,
                      context.packageManager.getLaunchIntentForPackage(context.packageName)!!
                          .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP),
                      flags
                  )
                  val n = NotificationCompat.Builder(context, CHANNEL_ID)
                      .setSmallIcon(android.R.drawable.ic_menu_edit)
                      .setContentTitle("一日之计在于昨晚")
                      .setContentText("现在用1分钟整理明日任务清单吧")
                      .setContentIntent(openApp)
                      .setAutoCancel(true)
                      .build()
                  nm.notify(NOTI_ID, n)
              }

              private fun pending(context: Context): PendingIntent {
                  val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
                      PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE else PendingIntent.FLAG_UPDATE_CURRENT
                  val intent = Intent(context, NightlyPlannerReceiver::class.java)
                  return PendingIntent.getBroadcast(context, 1001, intent, flags)
              }

              private fun ensureChannel(context: Context) {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                      val ch = NotificationChannel(CHANNEL_ID, "Nightly Planner", NotificationManager.IMPORTANCE_DEFAULT)
                      ch.setShowBadge(false)
                      nm.createNotificationChannel(ch)
                  }
              }
          }
          KOT

          # ---------- NightlyPlannerReceiver.kt (handles alarm + BOOT) ----------
          cat > android/app/src/main/kotlin/$ORG_PATH/NightlyPlannerReceiver.kt <<'KOT'
          package com.example.antipro

          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.content.Intent.ACTION_BOOT_COMPLETED

          class NightlyPlannerReceiver : BroadcastReceiver() {
              override fun onReceive(context: Context, intent: Intent?) {
                  if (intent?.action == ACTION_BOOT_COMPLETED) {
                      NightlyPlanner.rescheduleFromPrefs(context)
                  } else {
                      NightlyPlanner.showReminder(context)
                  }
              }
          }
          KOT

          # ---------- activity_focus_lock.xml ----------
          cat > android/app/src/main/res/layout/activity_focus_lock.xml <<'XML'
          <?xml version="1.0" encoding="utf-8"?>
          <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:background="#000000">

              <TextView
                  android:id="@+id/countdownText"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text="25:00"
                  android:textColor="#FFFFFF"
                  android:textSize="56sp"
                  android:textStyle="bold"
                  android:layout_gravity="center" />
          </FrameLayout>
          XML

          # ---------- AndroidManifest.xml (no package=, add BOOT receiver) ----------
          cat > android/app/src/main/AndroidManifest.xml <<'XML'
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

              <application
                  android:label="Anti Pro"
                  android:name="${applicationName}"
                  android:icon="@mipmap/ic_launcher">
                  <meta-data android:name="flutterEmbedding" android:value="2" />

                  <activity
                      android:name="com.example.antipro.MainActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:theme="@style/LaunchTheme"
                      android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
                      android:hardwareAccelerated="true"
                      android:windowSoftInputMode="adjustResize">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <activity
                      android:name="com.example.antipro.FocusLockActivity"
                      android:exported="false"
                      android:showWhenLocked="true"
                      android:turnScreenOn="true"
                      android:excludeFromRecents="true" />

                  <service
                      android:name="com.example.antipro.FocusForegroundService"
                      android:exported="false" />

                  <receiver
                      android:name="com.example.antipro.NightlyPlannerReceiver"
                      android:enabled="true"
                      android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.BOOT_COMPLETED" />
                      </intent-filter>
                  </receiver>
              </application>
          </manifest>
          XML

      - name: Sanitize manifests (remove any leftover package="…")
        run: |
          set -euo pipefail
          shopt -s globstar || true
          for f in android/app/src/**/AndroidManifest.xml; do
            [ -f "$f" ] || continue
            sed -i 's/\s*package="[^"]*"//g' "$f"
          done
          echo "Checked & sanitized AndroidManifest.xml files."

      - name: Flutter pub get
        run: |
          set -euo pipefail
          flutter pub get

      - name: Build arm64 release (split-per-abi, tree-shake icons)
        run: |
          set -euo pipefail
          flutter build apk --release --target-platform=android-arm64 --split-per-abi --tree-shake-icons

      - name: List APKs (diagnostic)
        run: |
          set -euo pipefail
          echo "== Searching for APKs under build/ =="
          find build -type f -name "*.apk" 2>/dev/null | sort -u || true
          echo "== Searching for APKs under repository root (fallback) =="
          find . -type f -name "*.apk" 2>/dev/null | sort -u || true

      - name: Locate & stage APK
        id: stage_apk
        run: |
          set -euo pipefail
          # Prefer split-per-abi arm64 filename
          try() { find "$1" -type f -name "$2" 2>/dev/null | head -n1 || true; }
          APK="$(try build 'app-arm64-v8a-release.apk')"
          if [ -z "${APK:-}" ]; then APK="$(try build 'app-release.apk')"; fi
          if [ -z "${APK:-}" ]; then APK="$(find build -type f -name '*.apk' 2>/dev/null | head -n1 || true)"; fi
          if [ -z "${APK:-}" ]; then APK="$(find . -type f -name '*.apk' 2>/dev/null | head -n1 || true)"; fi

          if [ -z "${APK:-}" ]; then
            echo "apk_found=false" >> "$GITHUB_OUTPUT"
            echo "No APK found anywhere."
            exit 0
          fi

          mkdir -p dist
          cp -f "$APK" "dist/"
          OUT="dist/$(basename "$APK")"
          echo "Staged APK at: $OUT"
          echo "apk_found=true" >> "$GITHUB_OUTPUT"
          echo "apk_path=$OUT" >> "$GITHUB_OUTPUT"
          echo "apk_name=$(basename "$OUT")" >> "$GITHUB_OUTPUT"

      - name: Upload APK
        if: ${{ steps.stage_apk.outputs.apk_found == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.stage_apk.outputs.apk_name }}
          path: ${{ steps.stage_apk.outputs.apk_path }}
          retention-days: 10

      - name: Fail if missing artifact
        if: ${{ steps.stage_apk.outputs.apk_found != 'true' }}
        run: |
          echo '::error::No APK found to upload. Check "List APKs (diagnostic)" output above.'
          exit 1
