name: Build Android APK v0.3.6 - Foreground Service AOD (arm64, fix appcompat)

on:
  workflow_dispatch: {}

defaults:
  run:
    shell: bash

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Flutter (stable)
        uses: subosito/flutter-action@v2
        with:
          channel: stable

      - name: Create Flutter project if missing (no overwrite)
        run: |
          set -euo pipefail
          if [ ! -f pubspec.yaml ]; then
            flutter create . --platforms=android --project-name anti_procrastination --org com.example.antipro
          fi

      - name: Detect legacy Android v1 embedding
        id: detect_v1
        run: |
          set -euo pipefail
          hits="$(grep -R -nE 'io\.flutter\.app\.Flutter(Application|Activity)|registerWith\(' android || true)"
          if [ -n "$hits" ]; then
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "$hits"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Regenerate android/ with embedding v2 (if needed)
        if: ${{ steps.detect_v1.outputs.found == 'true' }}
        run: |
          set -euo pipefail
          rm -rf android
          flutter create . --platforms=android --project-name anti_procrastination --org com.example.antipro --overwrite

      - name: Generate temp keystore & key.properties (sign release)
        run: |
          set -euo pipefail
          mkdir -p android/app
          keytool -genkey -noprompt \
            -keystore android/app/upload-keystore.jks \
            -alias upload \
            -storepass android -keypass android \
            -keyalg RSA -keysize 2048 -validity 10000 \
            -dname "CN=Temp, OU=CI, O=CI, L=, S=, C=US"
          cat > android/key.properties <<'PROPS'
          storePassword=android
          keyPassword=android
          keyAlias=upload
          storeFile=upload-keystore.jks
          PROPS

      - name: Inject native (Kotlin Service + Lock Activity + Manifest w/ embedding=2, no package attr)
        run: |
          set -euo pipefail
          ORG_PATH="com/example/antipro"
          mkdir -p android/app/src/main/kotlin/$ORG_PATH
          mkdir -p android/app/src/main/res/layout

          # ---------- MainActivity.kt ----------
          cat > android/app/src/main/kotlin/$ORG_PATH/MainActivity.kt <<'KOT'
          package com.example.antipro

          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.content.IntentFilter
          import android.os.Build
          import android.os.Handler
          import android.os.Looper
          import io.flutter.embedding.android.FlutterActivity
          import io.flutter.embedding.engine.FlutterEngine
          import io.flutter.plugin.common.MethodChannel

          class MainActivity : FlutterActivity() {
              private val CHANNEL = "focus_service"
              private var eventsReceiver: BroadcastReceiver? = null

              companion object {
                  var channel: MethodChannel? = null
                  fun emit(method: String, args: Map<String, Any?>? = null) {
                      val ch = channel ?: return
                      Handler(Looper.getMainLooper()).post { ch.invokeMethod(method, args) }
                  }
              }

              override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
                  super.configureFlutterEngine(flutterEngine)
                  val ch = MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL)
                  channel = ch
                  ch.setMethodCallHandler { call, result ->
                      when (call.method) {
                          "start" -> {
                              val minutes = (call.argument<Int>("minutes") ?: 25)
                              val dim = (call.argument<Double>("dim") ?: 0.05).toFloat()
                              val lock = (call.argument<Boolean>("lock") ?: false)

                              val svc = Intent(this, FocusForegroundService::class.java)
                              svc.putExtra("minutes", minutes)
                              startForegroundServiceCompat(svc)

                              if (lock) {
                                  val intent = Intent(this, FocusLockActivity::class.java)
                                  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
                                  intent.putExtra("dim", dim)
                                  startActivity(intent)
                              }
                              result.success(true)
                          }
                          "stop" -> {
                              stopService(Intent(this, FocusForegroundService::class.java))
                              result.success(true)
                          }
                          else -> result.notImplemented()
                      }
                  }
              }

              override fun onStart() {
                  super.onStart()
                  val filter = IntentFilter().apply {
                      addAction("FOCUS_TICK"); addAction("FOCUS_FINISH"); addAction("FOCUS_STOP"); addAction("FOCUS_INTERRUPTION")
                  }
                  eventsReceiver = object : BroadcastReceiver() {
                      override fun onReceive(context: Context?, intent: Intent?) {
                          when (intent?.action) {
                              "FOCUS_TICK" -> emit("onTick", mapOf("remaining" to intent.getIntExtra("remaining", 0)))
                              "FOCUS_FINISH" -> emit("onFinish")
                              "FOCUS_STOP" -> emit("onStop")
                              "FOCUS_INTERRUPTION" -> emit("onInterruption")
                          }
                      }
                  }
                  registerReceiver(eventsReceiver, filter)
              }

              override fun onStop() {
                  try { unregisterReceiver(eventsReceiver) } catch (_: Exception) {}
                  eventsReceiver = null
                  super.onStop()
              }

              private fun startForegroundServiceCompat(intent: Intent) {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) startForegroundService(intent) else startService(intent)
              }
          }
          KOT

          # ---------- FocusForegroundService.kt ----------
          cat > android/app/src/main/kotlin/$ORG_PATH/FocusForegroundService.kt <<'KOT'
          package com.example.antipro

          import android.app.Notification
          import android.app.NotificationChannel
          import android.app.NotificationManager
          import android.app.PendingIntent
          import android.app.Service
          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.content.IntentFilter
          import android.os.Build
          import android.os.CountDownTimer
          import android.os.IBinder
          import androidx.core.app.NotificationCompat

          class FocusForegroundService : Service() {
              private var timer: CountDownTimer? = null
              private var remainingMs: Long = 0L
              private var screenRx: BroadcastReceiver? = null

              override fun onCreate() {
                  super.onCreate()
                  createChannel()
                  // Count as "interruption" when user unlocks during focus
                  val f = IntentFilter().apply { addAction(Intent.ACTION_USER_PRESENT) }
                  screenRx = object : BroadcastReceiver() {
                      override fun onReceive(context: Context?, intent: Intent?) {
                          if (intent?.action == Intent.ACTION_USER_PRESENT && remainingMs > 0L) {
                              sendBroadcast(Intent("FOCUS_INTERRUPTION"))
                          }
                      }
                  }
                  registerReceiver(screenRx, f)
              }

              override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
                  if (intent?.action == "STOP") {
                      sendBroadcast(Intent("FOCUS_STOP"))
                      stopForeground(STOP_FOREGROUND_REMOVE)
                      stopSelf()
                      // Bring app to front
                      try {
                          val launcher = packageManager.getLaunchIntentForPackage(packageName)
                          launcher?.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
                          if (launcher != null) startActivity(launcher)
                      } catch (_: Exception) {}
                      return START_NOT_STICKY
                  }
                  val minutes = intent?.getIntExtra("minutes", 25) ?: 25
                  remainingMs = (minutes * 60 * 1000L)
                  startForeground(NOTI_ID, buildNotification(formatRemaining()))
                  timer?.cancel()
                  timer = object : CountDownTimer(remainingMs, 1000) {
                      override fun onTick(ms: Long) {
                          remainingMs = ms
                          notifyUpdate()
                          val i = Intent("FOCUS_TICK"); i.putExtra("remaining", (remainingMs / 1000).toInt()); sendBroadcast(i)
                      }
                      override fun onFinish() {
                          sendBroadcast(Intent("FOCUS_FINISH"))
                          stopForeground(STOP_FOREGROUND_DETACH)
                          stopSelf()
                      }
                  }.start()
                  return START_STICKY
              }

              override fun onDestroy() {
                  timer?.cancel()
                  try { unregisterReceiver(screenRx) } catch (_: Exception) {}
                  super.onDestroy()
              }

              override fun onBind(intent: Intent?): IBinder? = null

              private fun notifyUpdate() {
                  val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                  nm.notify(NOTI_ID, buildNotification(formatRemaining()))
              }

              private fun formatRemaining(): String {
                  val totalSec = (remainingMs / 1000).toInt()
                  val m = totalSec / 60
                  val s = totalSec % 60
                  return String.format("%02d:%02d", m, s)
              }

              private fun createChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                      val ch = NotificationChannel(CHANNEL_ID, "Focus", NotificationManager.IMPORTANCE_DEFAULT)
                      ch.setShowBadge(false)
                      nm.createNotificationChannel(ch)
                  }
              }

              private fun buildNotification(text: String): Notification {
                  val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
                      PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE else PendingIntent.FLAG_UPDATE_CURRENT
                  val pi = PendingIntent.getActivity(
                      this, 0,
                      Intent(this, FocusLockActivity::class.java).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP),
                      flags
                  )
                  val stopPi = PendingIntent.getService(this, 1, Intent(this, FocusForegroundService::class.java).setAction("STOP"), flags)
                  return NotificationCompat.Builder(this, CHANNEL_ID)
                      .setSmallIcon(android.R.drawable.ic_lock_idle_alarm)
                      .setContentTitle("专注进行中")
                      .setContentText("剩余: $text")
                      .setOngoing(true)
                      .setOnlyAlertOnce(true)
                      .setContentIntent(pi)
                      .addAction(0, "停止", stopPi)
                      .setCategory(NotificationCompat.CATEGORY_SERVICE)
                      .build()
              }

              companion object {
                  private const val CHANNEL_ID = "focus_channel"
                  private const val NOTI_ID = 2001
              }
          }
          KOT

          # ---------- FocusLockActivity.kt (extends Activity, NO appcompat) ----------
          cat > android/app/src/main/kotlin/$ORG_PATH/FocusLockActivity.kt <<'KOT'
          package com.example.antipro

          import android.app.Activity
          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.content.IntentFilter
          import android.os.Bundle
          import android.view.View
          import android.view.WindowManager
          import android.widget.TextView

          class FocusLockActivity : Activity() {
              private var tv: TextView? = null
              private val rx = object : BroadcastReceiver() {
                  override fun onReceive(context: Context?, intent: Intent?) {
                      when (intent?.action) {
                          "FOCUS_TICK" -> {
                              val sec = intent.getIntExtra("remaining", 0)
                              val m = sec / 60; val s = sec % 60
                              tv?.text = String.format("%02d:%02d", m, s)
                          }
                          "FOCUS_FINISH", "FOCUS_STOP" -> finish()
                      }
                  }
              }

              override fun onCreate(savedInstanceState: Bundle?) {
                  super.onCreate(savedInstanceState)
                  setContentView(R.layout.activity_focus_lock)
                  tv = findViewById(R.id.countdownText)

                  window.addFlags(
                      WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED or
                      WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON or
                      WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
                  )
                  val dim = intent.getFloatExtra("dim", 0.05f).coerceIn(0.01f, 0.2f)
                  window.attributes = window.attributes.apply { screenBrightness = dim }

                  window.decorView.systemUiVisibility = (
                      View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or
                      View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or
                      View.SYSTEM_UI_FLAG_FULLSCREEN)
              }

              override fun onResume() {
                  super.onResume()
                  registerReceiver(rx, IntentFilter().apply {
                      addAction("FOCUS_TICK"); addAction("FOCUS_FINISH"); addAction("FOCUS_STOP")
                  })
              }

              override fun onPause() {
                  try { unregisterReceiver(rx) } catch (_: Exception) {}
                  super.onPause()
              }
          }
          KOT

          # ---------- activity_focus_lock.xml ----------
          cat > android/app/src/main/res/layout/activity_focus_lock.xml <<'XML'
          <?xml version="1.0" encoding="utf-8"?>
          <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:background="#000000">

              <TextView
                  android:id="@+id/countdownText"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text="25:00"
                  android:textColor="#FFFFFF"
                  android:textSize="56sp"
                  android:textStyle="bold"
                  android:layout_gravity="center" />
          </FrameLayout>
          XML

          # ---------- AndroidManifest.xml (no package=, FQCN components) ----------
          cat > android/app/src/main/AndroidManifest.xml <<'XML'
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />

              <application
